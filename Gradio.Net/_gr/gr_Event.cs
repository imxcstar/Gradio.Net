using Gradio.Net.Enums;

namespace Gradio.Net;

public static partial class gr
{
    public static async Task End<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveEndEvent
    {
        await Events.End.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task End<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveEndEvent
    {
        await Events.End.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Pause<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHavePauseEvent
    {
        await Events.Pause.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Pause<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHavePauseEvent
    {
        await Events.Pause.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Play<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHavePauseEvent
    {
        await Events.Play.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Play<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHavePauseEvent
    {
        await Events.Play.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Stop<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStopEvent
    {
        await Events.Stop.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Stop<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStopEvent
    {
        await Events.Stop.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task StopRecording<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStopRecordingEvent
    {
        await Events.StopRecording.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task StopRecording<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStopRecordingEvent
    {
        await Events.StopRecording.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task StartRecording<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStartRecordingEvent
    {
        await Events.StartRecording.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task StartRecording<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStartRecordingEvent
    {
        await Events.StartRecording.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task PauseRecording<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHavePauseRecordingEvent
    {
        await Events.PauseRecording.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task PauseRecording<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHavePauseRecordingEvent
    {
        await Events.PauseRecording.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Upload<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveUploadEvent
    {
        await Events.Upload.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Upload<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveUploadEvent
    {
        await Events.Upload.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Stream<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStreamEvent
    {
        await Events.Stream.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Stream<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveStreamEvent
    {
        await Events.Stream.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Clear<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveClearEvent
    {
        await Events.Clear.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Clear<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveClearEvent
    {
        await Events.Clear.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Click<T>(this T block,
       Func<Input, Task<Output>> fn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveClickEvent
    {
        await Events.Click.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Click<T>(this T block,
       Func<Input, IAsyncEnumerable<Output>> streamingFn,
       IEnumerable<Component> inputs = null,
       IEnumerable<Component> outputs = null,
       string apiName = null,
       bool scrollToOutput = false,
       ShowProgress showProgress = ShowProgress.Full,
       bool? queue = null,
       bool batch = false,
       int maxBatchSize = 4,
       bool preprocess = true,
       bool postprocess = true,
       Dictionary<string, object> cancels = null,
       decimal? every = null,
       TriggerMode? triggerMode = null,
       string js = null,
       ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
       string concurrencyId = null,
       bool showApi = true) where T : Block, IHaveClickEvent
    {
        await Events.Click.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Input<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveInputEvent
    {
        await Events.Input.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Input<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveInputEvent
    {
        await Events.Input.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Release<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveReleaseEvent
    {
        await Events.Release.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Release<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveReleaseEvent
    {
        await Events.Release.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Blur<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveBlurEvent
    {
        await Events.Blur.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Blur<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveBlurEvent
    {
        await Events.Blur.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Focus<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveFocusEvent
    {
        await Events.Focus.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Focus<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveFocusEvent
    {
        await Events.Focus.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Submit<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveSubmitEvent
    {
        await Events.Submit.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Submit<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveSubmitEvent
    {
        await Events.Submit.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Select<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveSelectEvent
    {
        await Events.Select.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Select<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveSelectEvent
    {
        await Events.Select.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Change<T>(this T block,
      Func<Input, Task<Output>> fn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveChangeEvent
    {
        await Events.Change.EventTrigger(block,
            fn: fn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }

    public static async Task Change<T>(this T block,
      Func<Input, IAsyncEnumerable<Output>> streamingFn,
      IEnumerable<Component> inputs = null,
      IEnumerable<Component> outputs = null,
      string apiName = null,
      bool scrollToOutput = false,
      ShowProgress showProgress = ShowProgress.Full,
      bool? queue = null,
      bool batch = false,
      int maxBatchSize = 4,
      bool preprocess = true,
      bool postprocess = true,
      Dictionary<string, object> cancels = null,
      decimal? every = null,
      TriggerMode? triggerMode = null,
      string js = null,
      ConcurrencyLimit concurrencyLimit = ConcurrencyLimit.Default,
      string concurrencyId = null,
      bool showApi = true) where T : Block, IHaveChangeEvent
    {
        await Events.Change.EventTrigger(block,
            streamingFn: streamingFn,
            inputs: inputs,
            outputs: outputs,
            apiName: apiName,
            scrollToOutput: scrollToOutput,
            showProgress: showProgress,
            queue: queue,
            batch: batch,
            maxBatchSize: maxBatchSize,
            preprocess: preprocess,
            postprocess: postprocess,
            cancels: cancels,
            every: every,
            triggerMode: triggerMode,
            js: js,
            concurrencyLimit: concurrencyLimit,
            concurrencyId: concurrencyId,
            showApi: showApi
            );
    }
}
